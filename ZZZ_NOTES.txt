1. app graph or modules graph
2. logging best practices: check
3. documentation: nestjs swagger package: https://youtu.be/DG0uZ0E8DBs?si=vu9lK8jGKMzdkxSS
=========


>> project structure inside src folder:
    >> modules: core application modules
    >> common: cross cutting, not bound to specific module.
                ### NOTE: we put only those things (ex gaurds) that are really common in various modules. otherwise prefer defining within the modules only.
                
                constants
                enums
                Guards (e.g., authentication or roles)
                filters
                Custom pipes
                Global services
                Interceptors
                Decorators
                Exceptions
                
    >> shared: domain specific(modules basically) code that may be used by multiple other modules.
                databasemodule
                loggermodule
                cachemodule
    >> config:
        >> configuration files only

    + we can have below folders as well as per need:
        filters/             # Global exception filters
        pipes/               # Custom pipes for validation or transformation
        guards/              # Custom guards for authorization/authentication
        interceptors/        # Interceptors for logging or response manipulation
        utils/      



>>   // const configService = app.get(ConfigService); // in nest managed classes, we could simply use dependency injection to get ConfigService, but here in main.ts, we do it this way.
>> dto validation:
    >> npm i --save class-validator class-transformer
    >> use built in pipes
    >> for mapped types: npm i --save @nestjs/mapped-types


>> we use default seuelize timestamps in our models. otherwise we would need this:
    >> @Column({
        type: DataType.DATE,
        allowNull: false,
        defaultValue: DataType.NOW, // Set default value to the current timestamp
      })
      created_at: Date;

      @Column({
        type: DataType.DATE,
        allowNull: false,
        defaultValue: DataType.NOW, // Set default value to the current timestamp
      })
      updated_at: Date;

>> exception handling
  >> will use custom exceptions only when really required. otherwise depend on built in ones.
    >> so we will see very less try/catch
  >> will be handling exceptions in exception filter.


>> seuelize model instance build and update:
  >> task.build({...createTaskDto});
  >> task.update({...updateTaskDto});

  we could achive the same by directly passing the dtos. afterall sequelize just needs object having key/value.
  But, it is a best practice to pass a seperate instance created using spread operator.

  >> RELATED NOTE:
    >> build + save <=> create
    >> set + save <=> update

>> priority/status: validation or related things


>> IMPORTANT:
CODE 1
==

@Delete(':id')
    async deleteTask(@Param('id') id:number):Promise<void>{
        await this.tasksService.deleteTask(id);
        return;
    }

+

async deleteTask(id:number):Promise<void>{
        const task = await this.taskModel.findByPk(id);
        if(!task){
            throw new NotFoundException(`Task does not exist`);
        }
        await task.destroy();
    }

VS CODE 2
==

@Delete(':id')
    async deleteTask(@Param('id') id:number):Promise<void>{
        return this.tasksService.deleteTask(id);
    }
+

async deleteTask(id:number):Promise<void>{
        const task = await this.taskModel.findByPk(id);
        if(!task){
            throw new NotFoundException(`Task does not exist`);
        }
        return task.destroy(); // no await
    }

## why do we get deleted response back in case of code 2.


===================================== logging
>> see config folder + shared folder
>> 2 files are generated in root: combined.log, error.log
>> we have enabled on app modules, so we can use in any class under this.
    >> @Inject(WINSTON_MODULE_PROVIDER) private readonly logger: Logger
    >> this.logger.info("API HIT: GET TASKS")

>> in this app we are logging request response. we have done this in an interceptor.


================= environemnt + config
>> npm install @nestjs/config dotenv
>> nest config module. set Global
>> at last work on env-validator too[optional but best practice]


===========
IMPORTANT: 2 ways
// SequelizeModule.forRoot(sequelizeModuleOptionsObject) // used when no need to inject config service. i.e., when fix values are used.
SequelizeModule.forRootAsync({
    inject:[ConfigService],
    useFactory:(configService:ConfigService)=> getSequelizeModuleOptions(configService)
})

## same for winston module too.

====================== interceptor
>> know the concept already.
>> next.handle() is the point when your control method is invoked.
    >> so anything that you want to do before controller's handling, do it before next.handle
    >> and anything that you want to after controller's return, do in next.handle().pipe()
>> i have created in interceptors folder. and applied for test on task controller.
    >> it works. let's apply this globally in main.ts.


============== CACHING
>> suitable strategy: write around
    >> write to db.
    >> on first demand for this, load from db and cache the result.
    >> invalidate when there is an update.

>> dependency:
    >> npm install @nestjs/cache-manager
    >> we also need cache-manager dependency. but cache manager latest is not supported by @nestjs/cache-manager.
        >> we need <= 5 version.
        >> cache-manager@5.0.0
    >> for cache store, we have multiple options. by default In memory store is used. But let's use redis.
        >> npm i cache-manager-redis-yet@5.0.0 [this is deperecated. cache manager 5 supports it but nat later.]

>> configure in a seperate module[can be done in app module too, but lets make it clean.]:
    >> READ ABOUT GLOBAL AND NON GLOBAL MODULE BEHAVIORS.
    >> It is quite clear that to use a module's services into another, we import the module.
       But, how global modules need to be imported once only in any module[generally app] and then they are available throughout tha app.

>> after configuration, we can use the manager by injecting it in any class. [DOING IN TASK SERVICE for test. ]
constructor(@Inject(CACHE_MANAGER) private cacheManager: Cache) {}
// TESTING CACHING ON THIS METHOD
    async getTaskById(id: number): Promise<Task>{
        // Look into cache. If found, return.
        const cached = await this.cacheManager.get<string>(`tasks:${id}`);
        if(cached){
            return JSON.parse(cached);
        }

        // Else, hit database. And write to cache.
        const task = await this.taskModel.findByPk(id);
        if(!task){
            throw new NotFoundException(`Task does not exist`);
        }
        await this.cacheManager.set(`tasks:${id}`, JSON.stringify(task), 1000*60);
        return task;
    }

    This worked.

>> Now, lets test response auto caching(get endpoints only) with task controller.
    >> Very simple:
        @UseInterceptors(CacheInterceptor)
        @CacheTTL(60000) // 1 Minute expiration.

    >> we can override caching properties for individual routes also.
        @CacheKey('custom_key')
        @CacheTTL(20)

>> ALSO SEE THE BELOW: to apply the cache manager globally, do in app module. [NOT DOING THIS in this project]
providers: [
    {
      provide: APP_INTERCEPTOR,
      useClass: CacheInterceptor,
    },
  ],

### IMPORTANT:
    >> your app is running. and suddenly redis server is down. this crashes the app. see how to fix.
    >> see why ttl default ttl is not working.

========== RABBIT MESSAGING
>> done in rabbit manager module
>> the module is made global.

>> MERGE IN CACHING BRANCH. THEN MERGE CACHING IN MAIN.