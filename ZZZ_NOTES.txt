1. app graph or modules graph
2. logging best practices: check
3. documentation: nestjs swagger package: https://youtu.be/DG0uZ0E8DBs?si=vu9lK8jGKMzdkxSS
=========


>> project structure inside src folder:
    >> modules: core application modules
    >> common: cross cutting, not bound to specific module.
                ### NOTE: we put only those things (ex gaurds) that are really common in various modules. otherwise prefer defining within the modules only.
                
                constants
                enums
                Guards (e.g., authentication or roles)
                filters
                Custom pipes
                Global services
                Interceptors
                Decorators
                Exceptions
                
    >> shared: domain specific(modules basically) code that may be used by multiple other modules.
                databasemodule
                loggermodule
                cachemodule
    >> config:
        >> configuration files only

    + we can have below folders as well as per need:
        filters/             # Global exception filters
        pipes/               # Custom pipes for validation or transformation
        guards/              # Custom guards for authorization/authentication
        interceptors/        # Interceptors for logging or response manipulation
        utils/      



>>   // const configService = app.get(ConfigService); // in nest managed classes, we could simply use dependency injection to get ConfigService, but here in main.ts, we do it this way.
>> dto validation:
    >> npm i --save class-validator class-transformer
    >> use built in pipes
    >> for mapped types: npm i --save @nestjs/mapped-types


>> we use default seuelize timestamps in our models. otherwise we would need this:
    >> @Column({
        type: DataType.DATE,
        allowNull: false,
        defaultValue: DataType.NOW, // Set default value to the current timestamp
      })
      created_at: Date;

      @Column({
        type: DataType.DATE,
        allowNull: false,
        defaultValue: DataType.NOW, // Set default value to the current timestamp
      })
      updated_at: Date;

>> exception handling
  >> will use custom exceptions only when really required. otherwise depend on built in ones.
    >> so we will see very less try/catch
  >> will be handling exceptions in exception filter.


>> seuelize model instance build and update:
  >> task.build({...createTaskDto});
  >> task.update({...updateTaskDto});

  we could achive the same by directly passing the dtos. afterall sequelize just needs object having key/value.
  But, it is a best practice to pass a seperate instance created using spread operator.

  >> RELATED NOTE:
    >> build + save <=> create
    >> set + save <=> update

>> priority/status: validation or related things


>> IMPORTANT:
CODE 1
==

@Delete(':id')
    async deleteTask(@Param('id') id:number):Promise<void>{
        await this.tasksService.deleteTask(id);
        return;
    }

+

async deleteTask(id:number):Promise<void>{
        const task = await this.taskModel.findByPk(id);
        if(!task){
            throw new NotFoundException(`Task does not exist`);
        }
        await task.destroy();
    }

VS CODE 2
==

@Delete(':id')
    async deleteTask(@Param('id') id:number):Promise<void>{
        return this.tasksService.deleteTask(id);
    }
+

async deleteTask(id:number):Promise<void>{
        const task = await this.taskModel.findByPk(id);
        if(!task){
            throw new NotFoundException(`Task does not exist`);
        }
        return task.destroy(); // no await
    }

## why do we get deleted response back in case of code 2.


===================================== logging
>> see config folder + shared folder
>> 2 files are generated in root: combined.log, error.log
>> we have enabled on app modules, so we can use in any class under this.
    >> @Inject(WINSTON_MODULE_PROVIDER) private readonly logger: Logger
    >> this.logger.info("API HIT: GET TASKS")

>> in this app we are logging request response. we have done this in an interceptor.


================= environemnt + config
>> npm install @nestjs/config dotenv
>> nest config module. set Global
>> at last work on env-validator too[optional but best practice]


===========
IMPORTANT: 2 ways
// SequelizeModule.forRoot(sequelizeModuleOptionsObject) // used when no need to inject config service. i.e., when fix values are used.
SequelizeModule.forRootAsync({
    inject:[ConfigService],
    useFactory:(configService:ConfigService)=> getSequelizeModuleOptions(configService)
})

## same for winston module too.

====================== interceptor
>> know the concept already.
>> next.handle() is the point when your control method is invoked.
    >> so anything that you want to do before controller's handling, do it before next.handle
    >> and anything that you want to after controller's return, do in next.handle().pipe()
>> i have created in interceptors folder. and applied for test on task controller.
    >> it works. let's apply this globally in main.ts.

